scopeName: source.typst
name: Typst

# VS Code has an automatic brace matching feature, which we sometimes need to
# disable. In the VS Code extension's `package.json`, we tell VS Code not to
# perform brace matching for:
# - `punctuation.nonmatching.typst`
# - `constant.character.escape.nonmatching.typst`
# - `text.nonmatching.typst`

patterns:
  - { include: "#markup" }

repository:
  #########################################
  # Common patterns
  #########################################
  common:
    patterns:
      - { include: "#cmn-whitespace" }
      - { include: "#cmn-line-comment" }
      - { include: "#cmn-block-comment" }

  # Trivia, which is skipped in math and code
  cmn-trivia:
    patterns:
      - { include: "#cmn-whitespace" }
      - { include: "#cmn-line-comment" }
      - { include: "#cmn-block-comment" }

  # Whitespace
  cmn-whitespace:
    match: \p{White_Space}+

  # Single line comment beginning with //
  cmn-line-comment:
    name: comment.line.double-slash.typst
    match: //.*$

  # Block comment between /* and */
  cmn-block-comment:
    name: comment.block.typst
    begin: /\*
    end: \*/
    # Typst allows for "recursive" block comments, so a block comment won't end
    # at the first */ if there's another /* first. A terminating */ can also be
    # "commented out" with //
    patterns:
      - { include: "#cmn-block-comment" }
      - { include: "#cmn-line-comment" }

  # Starts with \
  # Same for markup and math
  mkp-math-backslash:
    patterns:
      # Unicode escape
      - name: constant.character.escape.typst
        match: \\u{[a-zA-Z0-9]*}?

      # Linebreak
      - name: constant.character.escape.typst
        match: \\($|\s)
        captures:
          0:
            name: punctuation.nonmatching.typst

      # Escape that VS Code would try to perform brace matching on
      - name: constant.character.escape.typst
        match: \\[\[\](){}]
        captures:
          0:
            name: punctuation.nonmatching.typst

      # Escape
      - name: constant.character.escape.content.typst
        match: \\.?

  # Hash, which enters code mode
  # Same for markup and math
  mkp-math-hash:
    # Hashes are supposed to be highlighted based on the syntax that
    # follows, but for simplicity, we just color it as an operator
    name: keyword.operator.typst
    match: \#

  # String literal
  # Same for math and code
  math-code-string:
    name: string.quoted.double.typst
    begin: '"'
    end: '"'
    # We have to prevent the end pattern from matching against an escaped quote,
    # so we need to eat all escaped quotes. But we also have to be sure we don't
    # eat something like `\\"`, where the quote isn't actually escaped (assuming
    # that is preceded by more backslashes, at least). So we eat all escaped
    # pairs.
    patterns:
      - match: \\.

  #########################################
  # Markup patterns
  #########################################
  markup:
    patterns:
      - { include: "#mkp-nesting" }
      - { include: "#common" }
      - { include: "#mkp-math-backslash" }
      - { include: "#mkp-raw" }
      - { include: "#mkp-link" }
      - { include: "#mkp-label" }
      - { include: "#mkp-ref" }
      - { include: "#mkp-shorthand" }
      - { include: "#mkp-strong" }
      - { include: "#mkp-emph" }
      - { include: "#mkp-math-hash" }
      - { include: "#mkp-punctuation" }
      - { include: "#mkp-smart-quote" }
      - { include: "#mkp-math" }
      - { include: "#mkp-equal" }
      - { include: "#mkp-list" }
      - { include: "#mkp-text" }

  # Nesting within markup using [ ... ]. This prevents paired delimiters, e.g.
  # *strong stars*, from ending within a nested section, e.g.
  # `*bold [*this is also bold*] bold*`
  mkp-nesting:
    begin: \[
    end: \]
    captures:
      0:
        # It doesn't really make sense to enable bracket matching here, but it
        # wouldn't necessarily be wrong, since these brackets do match
        name: punctuation.nonmatching.typst
    patterns:
      - { include: "#markup" }

  # Raw/starts with `
  mkp-raw:
    patterns:
      # Embedded languages
      # TODO: generate this programmatically
      # For info on Typst's default supported languages, see here:
      # https://github.com/typst/typst/blob/9926a594e7f462103b47930270a00c1b9ce3cbf3/crates/typst/src/text/raw.rs#L735
      - contentName: meta.embedded.block.typst
        begin: (`{3,})(?i:typ|typst)(?=\s|$)
        end: \1
        patterns:
          - { include: $self }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.typc
        begin: (`{3,})(?i:typc)(?=\s|$)
        end: \1
        patterns:
          - { include: "#code" }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.json
        begin: (`{3,})(?i:json)(?=\s|$)
        end: \1
        patterns:
          - { include: source.json }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.html
        begin: (`{3,})(?i:html)(?=\s|$)
        end: \1
        patterns:
          - { include: text.html.derivative }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.rust
        begin: (`{3,})(?i:rs|rust)(?=\s|$)
        end: \1
        patterns:
          - { include: source.rust }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.ocaml
        begin: (`{3,})(?i:ml|mli|ocaml)(?=\s|$)
        end: \1
        patterns:
          - { include: source.ocaml }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: markup.raw.block.typst
        begin: "`{3,}"
        end: \0
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: markup.raw.inline.typst
        begin: "`"
        end: "`"
        captures:
          "0":
            name: punctuation.definition.raw.typst

  # Links
  mkp-link:
    name: markup.underline.link.typst
    # Typst checks for balanced parenthesis and brackets and stops lexing
    # links where those are not balanced, but for simplicity, we ignore
    # this case. Semantic highlighting should usually hide this problem if
    # it does come up, but the functionality can be added here if it
    # causes problems in the future.
    match: https?://([0-9a-zA-Z!#$%&*+,\-./:;=?@_~'\[(\]\)]*[0-9a-zA-Z#$%&*+\-/=@_~\[(\]\)]+)?

  # Labels
  mkp-label:
    patterns:
      - name: entity.name.label.typst
        match: <[\p{XID_Continue}_\-:.]+>

        # Label is empty or contains invalid characters/is unclosed
      - name: invalid.typst
        match: <[\p{XID_Continue}_\-:.]+([^\p{XID_Continue}_\-:.]*?>?|$)

  # Refs
  mkp-ref:
    patterns:
      # Reference like `@ref[content]`
      - begin: (@([\p{XID_Continue}_\-:.]*[\p{XID_Continue}_\-]+)?)\[
        end: "]"
        beginCaptures:
          1:
            name: markup.other.reference.typst
        patterns:
          - { include: "#markup" }

      # Reference like `@ref`
      - name: markup.other.reference.typst
        match: (@([\p{XID_Continue}_\-:.]*[\p{XID_Continue}_\-]+)?)

  # Shorthands/(multi)character abbreviations for hard-to-type Unicode chars
  mkp-shorthand:
    name: constant.character.escape.typst
    match: \.\.\.|---|--|-\?|-(?=\d)|~

  # Strong (usually bold) text *between stars*
  mkp-strong:
    name: markup.bold.typst
    # Typst checks that `*` is not in a "word". This is defined so that `*`
    # should match if it has a "non-wordy" char either before or after (or
    # there is no char before or after).
    #
    # A non-wordy char is one which is not alphanumeric or has script
    # Han, Hiragana, or Katakana.
    #
    # `/\p{Alphabetic}/` is equivalent to `char::is_alphabetic`
    # `/\p{Nd}|\p{Nl}|\p{No}/` is equivalent to `char::is_numeric`
    #
    # So the following matches a non-wordy char:
    # `/[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}]]/`
    begin: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])\*|\*(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])
    # Strong text can be terminated by `*` (expected) but also by `]` (so it
    # doesn't go past the end of a `#[...]` block) and a parbreak
    end: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])\*|\*(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])|]|^\s*$
    captures:
      0:
        name: punctuation.definition.bold.typst
    patterns:
      - { include: "#markup" }

  # Emphasized (usually italicized) text _between underscores_
  # See `mkp-strong`, which is very similar, for more on this rule
  mkp-emph:
    name: markup.italic.typst
    begin: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])_|_(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])
    end: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])_|_(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])|]|^\s*$
    captures:
      0:
        name: punctuation.definition.italic.typst
    patterns:
      - { include: "#markup" }

  # Punctuation.
  mkp-punctuation:
    patterns:
      # Unmatched [] should not match in markup mode
      - name: punctuation.nonmatching.typst
        match: ([\[\]])

      - name: punctuation.typst
        match: ":"

  # Smart quotes
  mkp-smart-quote:
    match: '"|'''

  # Math mode in markup
  mkp-math:
    begin: \$
    end: \$
    captures:
      0:
        # This isn't the officially recommended TM scope, but it seems to have
        # good support in themes.
        name: string.quoted.other.typst
        patterns:
          - name: punctuation.definition.math.typst
            match: .*
    patterns:
      - { include: "#math" }

  # Starts with =
  mkp-equal:
    patterns:
      # Heading
      - name: markup.heading.typst
        begin: =+(?=\s|$)
        # A heading is terminated by an end of a line, right bracket, or label
        end: (?=$|]|\s*(<[\p{XID_Continue}_\-:.]+>|<[\p{XID_Continue}_\-:.]+([^\p{XID_Continue}_\-:.]*?>?|$)))
        patterns:
          - { include: "#markup" }

      # Just `=` in text
      - name: meta.paragraph.typst
        match: =+

  # Lists. These rules could be expanded to more fully parse list items, but
  # that is difficult, likely does not matter for overall correct parsing, and
  # should be covered by semantic tokens regardless.
  mkp-list:
    patterns:
      # list, enum list, and term list markers
      # - ...   + ...   / ...
      # This isn't the officially recommended TM scope, but it seems to be
      # needed for some themes.
      - name: markup.list.typst
        match: ([\-+/](?=\p{White_Space}|$))
        captures:
          0:
            # This isn't an officially recommended TM scope, but it seems to be
            # needed for some themes.
            name: punctuation.definition.list.begin.typst
            patterns:
              - name: punctuation.definition.list.typst
                match: .*

      # numbered enum list markers
      # These are supposed to be checked by parsing as usize, but we skip that
      # here for simplicity. This likely only checks for overflow. This can be
      # added if needed.
      - name: punctuation.definition.list.typst
        match: ([0-9]+\.(?=\p{White_Space}|$))

  # Non-special text content
  mkp-text:
    patterns:
      # Parens should not match in markup mode
      - name: text.nonmatching.typst
        match: ([^ \t\n\x0b\x0c\r\\/\[\]~\-.'"*_:h`$<>@#]| (?=[\p{Alphabetic}\p{Nd}\p{Nl}\p{No}])|/(?![/*])|-(?![\-?])|\.(?!\.\.)|h(?!ttps?://)|@(?![\p{XID_Start}_]))+

  #########################################
  # Math patterns
  #########################################
  # Opening delimiters are matched by `/[(\[{⌈⌊⌜⌞❲⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼]/`
  # Closing delimiters are matched by `/[)\]}⌉⌋⌝⌟❳⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽]/`
  math:
    patterns:
      - { include: "#cmn-trivia" }
      - { include: "#mkp-math-backslash" }
      - { include: "#math-code-string" }
      - { include: "#math-shorthand" }
      - { include: "#mkp-math-hash" }
      - { include: "#math-op" }
      - { include: "#math-ident" }
      - { include: "#math-delim" }
      - { include: "#math-text" }

  # Shorthands/(multi)character abbreviations for hard-to-type Unicode chars
  math-shorthand:
    patterns:
      # Shorthand where VS Code would attempt to match brackets
      - name: constant.character.escape.typst
        match: \[\||\|]
        captures:
          0:
            name: constant.character.escape.nonmatching.typst

      # Most shorthands
      - name: constant.character.escape.typst
        match: ->>|->|-->|:=|::=|!=|\.\.\.|<==>|<-->|<--|<-<|<->|<<-|<<<|<=>|<==|<~~|<=|<<|<-|<~|>->|>>>|==>|=>|=:|>=|>>|\|->|\|=>|\|\||~~>|~>|\*|-

  # Math operators. Strictly speaking, `_/^` should be treated more carefully,
  # but this is likely acceptable for its intended purpose and is much simpler.
  math-op:
    name: keyword.operator.math.typst
    match: ([√∛∜&'_/\^])

  # Math identifiers
  math-ident:
    patterns:
      # Identifier followed by arguments
      - begin: (\p{XID_Start}[\p{XID_Continue}&&[^_]]+)(\()
        end: (\))|(?=\$)
        beginCaptures:
          1:
            name: meta.interpolation.typst
          2:
            name: punctuation.typst
        endCaptures:
          1:
            name: punctuation.typst
        patterns:
          - { include: "#math-args" }

      # Just an identifier
      - name: meta.interpolation.typst
        match: \p{XID_Start}[\p{XID_Continue}&&[^_]]+

  # Delimited math. This isn't actually allowed everywhere we highlight it, but
  # it seems to correctly highlight valid Typst, and is far simpler
  math-delim:
    begin: ([(\[{⌈⌊⌜⌞❲⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼])
    end: ([)\]}⌉⌋⌝⌟❳⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽])|(?=\$)
    # Prevent VS Code from attempting
    # bracket matching because the matching bracket can be a different kind of
    # bracket. For example, `(...]` is accepted.
    captures:
      1:
        name: text.nonmatching.typst
    patterns:
      - { include: "#math" }

  # Math text, which includes numerical literals and single characters
  # (technically single grapheme clusters)
  math-text:
    patterns:
      # Number
      - match: ([\p{Nd}\p{Nl}\p{No}]+)(\.[\p{Nd}\p{Nl}\p{No}]+)

      # Grapheme cluster. Prevent VS Code from attempting bracket matching if
      # the character happens to be a bracket.
      - name: text.nonmatching.typst
        match: \X

  #########################################
  # Math arg patterns
  #########################################
  math-args:
    patterns:
      - { include: "#cmn-trivia" }
      - { include: "#math-args-label" }
      - { include: "#math-args-sep" }
      - { include: "#math" }

  # Labels for named arguments, which is an ident or text followed by `:`
  math-args-label:
    match: (\p{XID_Start}[\p{XID_Continue}&&[^_]]+|[\p{Nd}\p{Nl}\p{No}]+(\.[\p{Nd}\p{Nl}\p{No}]+)|\X)(:)
    captures:
      1:
        name: meta.interpolation.typst
      3:
        name: punctuation.typst

  # Separators between arguments
  math-args-sep:
    match: ;|,
    captures:
      0:
        name: punctuation.typst
