scopeName: source.typst
name: Typst

# VS Code has an automatic brace matching feature, which we sometimes need to
# disable. In the VS Code extension's `package.json`, we tell VS Code not to
# perform brace matching for:
# - `punctuation.nonmatching.typst`
# - `text.nonmatching.typst`

patterns:
  - { include: "#markup" }

repository:
  #########################################
  # Common patterns
  #########################################
  common:
    patterns:
      - { include: "#cmn-whitespace" }
      - { include: "#cmn-line-comment" }
      - { include: "#cmn-block-comment" }

  # Whitespace
  cmn-whitespace:
    match: \p{White_Space}+

  # Single line comment beginning with //
  cmn-line-comment:
    name: comment.line.double-slash.typst
    match: //.*$

  # Block comment between /* and */
  cmn-block-comment:
    name: comment.block.typst
    begin: /\*
    end: \*/
    # Typst allows for "recursive" block comments, so a block comment won't end
    # at the first */ if there's another /* first. A terminating */ can also be
    # "commented out" with //
    patterns:
      - { include: "#cmn-block-comment" }
      - { include: "#cmn-line-comment" }

  #########################################
  # Markup patterns
  #########################################
  markup:
    patterns:
      - { include: "#mkp-nesting" }
      - { include: "#common" }
      - { include: "#mkp-backslash" }
      - { include: "#mkp-raw" }
      - { include: "#mkp-link" }
      - { include: "#mkp-label" }
      - { include: "#mkp-ref" }
      - { include: "#mkp-shorthand" }
      - { include: "#mkp-strong" }
      - { include: "#mkp-emph" }
      - { include: "#mkp-hash" }
      - { include: "#mkp-punctuation" }
      - { include: "#mkp-smart-quote" }
      - { include: "#mkp-dollar" }
      - { include: "#mkp-equal" }
      - { include: "#mkp-list" }
      - { include: "#mkp-text" }

  # Nesting within markup using [ ... ]. This prevents paired delimiters, e.g.
  # *strong stars*, from ending within a nested section, e.g.
  # `*bold [*this is also bold*] bold*`
  mkp-nesting:
    begin: \[
    end: \]
    captures:
      0:
        # It doesn't really make sense to enable bracket matching here, but it
        # wouldn't necessarily be wrong, since these brackets do match
        name: punctuation.nonmatching.typst
    patterns:
      - { include: "#markup" }

  # Starts with \
  mkp-backslash:
    patterns:
      # Unicode escape
      - name: constant.character.escape.typst
        match: \\u{[a-zA-Z0-9]*}?

      # Linebreak
      - name: constant.character.escape.typst
        match: \\($|\s)
        captures:
          0:
            name: punctuation.nonmatching.typst

      # Escape that VS Code would try to perform brace matching on
      - name: constant.character.escape.typst
        match: \\[\[\](){}]
        captures:
          0:
            name: punctuation.nonmatching.typst

      # Escape
      - name: constant.character.escape.content.typst
        match: \\.?

  # Raw/starts with `
  mkp-raw:
    patterns:
      # Embedded languages
      # TODO: generate this programmatically
      # For info on Typst's default supported languages, see here:
      # https://github.com/typst/typst/blob/9926a594e7f462103b47930270a00c1b9ce3cbf3/crates/typst/src/text/raw.rs#L735
      - contentName: meta.embedded.block.typst
        begin: (`{3,})(?i:typ|typst)(?=\s|$)
        end: \1
        patterns:
          - { include: $self }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.typc
        begin: (`{3,})(?i:typc)(?=\s|$)
        end: \1
        patterns:
          - { include: "#code" }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.json
        begin: (`{3,})(?i:json)(?=\s|$)
        end: \1
        patterns:
          - { include: source.json }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.html
        begin: (`{3,})(?i:html)(?=\s|$)
        end: \1
        patterns:
          - { include: text.html.derivative }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.rust
        begin: (`{3,})(?i:rs|rust)(?=\s|$)
        end: \1
        patterns:
          - { include: source.rust }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: meta.embedded.block.ocaml
        begin: (`{3,})(?i:ml|mli|ocaml)(?=\s|$)
        end: \1
        patterns:
          - { include: source.ocaml }
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: markup.raw.block.typst
        begin: "`{3,}"
        end: \0
        captures:
          "0":
            name: punctuation.definition.raw.typst

      - contentName: markup.raw.inline.typst
        begin: "`"
        end: "`"
        captures:
          "0":
            name: punctuation.definition.raw.typst

  # Links
  mkp-link:
    name: markup.underline.link.typst
    # Typst checks for balanced parenthesis and brackets and stops lexing
    # links where those are not balanced, but for simplicity, we ignore
    # this case. Semantic highlighting should usually hide this problem if
    # it does come up, but the functionality can be added here if it
    # causes problems in the future.
    match: https?://([0-9a-zA-Z!#$%&*+,\-./:;=?@_~'\[(\]\)]*[0-9a-zA-Z#$%&*+\-/=@_~\[(\]\)]+)?

  # Labels
  mkp-label:
    patterns:
      - name: entity.name.label.typst
        match: <[\p{XID_Continue}_\-:.]+>

        # Label is empty or contains invalid characters/is unclosed
      - name: invalid.typst
        match: <[\p{XID_Continue}_\-:.]+([^\p{XID_Continue}_\-:.]*?>?|$)

  # Refs
  mkp-ref:
    patterns:
      # Reference like `@ref[content]`
      - begin: (@([\p{XID_Continue}_\-:.]*[\p{XID_Continue}_\-]+)?)\[
        end: "]"
        beginCaptures:
          1:
            name: markup.other.reference.typst
        patterns:
          - { include: "#markup" }

      # Reference like `@ref`
      - name: markup.other.reference.typst
        match: (@([\p{XID_Continue}_\-:.]*[\p{XID_Continue}_\-]+)?)

  # Shorthands/(multi)character abbreviations for hard-to-type Unicode chars
  mkp-shorthand:
    name: constant.character.escape.typst
    match: \.\.\.|---|--|-\?|-(?=\d)|~

  # Strong (usually bold) text *between stars*
  mkp-strong:
    name: markup.bold.typst
    # Typst checks that `*` is not in a "word". This is defined so that `*`
    # should match if it has a "non-wordy" char either before or after (or
    # there is no char before or after).
    #
    # A non-wordy char is one which is not alphanumeric or has script
    # Han, Hiragana, or Katakana.
    #
    # `/\p{Alphabetic}/` is equivalent to `char::is_alphabetic`
    # `/\p{Nd}|\p{Nl}|\p{No}/` is equivalent to `char::is_numeric`
    #
    # So the following matches a non-wordy char:
    # `/[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}]]/`
    begin: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])\*|\*(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])
    # Strong text can be terminated by `*` (expected) but also by `]` (so it
    # doesn't go past the end of a `#[...]` block) and a parbreak
    end: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])\*|\*(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])|]|^\s*$
    captures:
      0:
        name: punctuation.definition.bold.typst
    patterns:
      - { include: "#markup" }

  # Emphasized (usually italicized) text _between underscores_
  # See `mkp-strong`, which is very similar, for more on this rule
  mkp-emph:
    name: markup.italic.typst
    begin: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])_|_(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])
    end: (?<=^|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])_|_(?=$|[[^\p{Alphabetic}\p{Nd}\p{Nl}\p{No}]\p{Han}\p{Hiragana}\p{Katakana}])|]|^\s*$
    captures:
      0:
        name: punctuation.definition.italic.typst
    patterns:
      - { include: "#markup" }

  # Hash, which enters code mode
  mkp-hash:
    # Hashes are supposed to be highlighted based on the syntax that
    # follows, but for simplicity, we just color it as an operator
    name: keyword.operator.typst
    match: \#

  # Punctuation.
  mkp-punctuation:
    patterns:
      # Unmatched [] should not match in markup mode
      - name: punctuation.nonmatching.typst
        match: ([\[\]])

      - name: punctuation.typst
        match: ":"

  # Smart quotes
  mkp-smart-quote:
    match: '"|'''

  # Dollar, which enters math mode
  mkp-dollar:
    name: punctuation.definition.math.typst
    match: \$

  # Starts with =
  mkp-equal:
    patterns:
      # Heading
      - name: markup.heading.typst
        begin: =+(?=\s|$)
        # A heading is terminated by an end of a line, right bracket, or label
        end: (?=$|]|\s*(<[\p{XID_Continue}_\-:.]+>|<[\p{XID_Continue}_\-:.]+([^\p{XID_Continue}_\-:.]*?>?|$)))
        patterns:
          - { include: "#markup" }

      # Just `=` in text
      - name: meta.paragraph.typst
        match: =+

  # Lists. These rules could be expanded to more fully parse list items, but
  # that is difficult, likely does not matter for overall correct parsing, and
  # should be covered by semantic tokens regardless.
  mkp-list:
    patterns:
      # list, enum list, and term list markers
      # - ...   + ...   / ...
      - name: punctuation.definition.list.typst
        match: ([\-+/](?=\p{White_Space}|$))

      # numbered enum list markers
      # These are supposed to be checked by parsing as usize, but we skip that
      # here for simplicity. This likely only checks for overflow. This can be
      # added if needed.
      - name: punctuation.definition.list.typst
        match: ([0-9]+\.(?=\p{White_Space}|$))

  # Non-special text content
  mkp-text:
    patterns:
      # Parens should not match in markup mode
      - name: text.nonmatching.typst
        match: ([^ \t\n\x0b\x0c\r\\/\[\]~\-.'"*_:h`$<>@#]| (?=[\p{Alphabetic}\p{Nd}\p{Nl}\p{No}])|/(?![/*])|-(?![\-?])|\.(?!\.\.)|h(?!ttps?://)|@(?![\p{XID_Start}_]))+

  #########################################
  # Code patterns
  #########################################
  # code:
  #   patterns:
